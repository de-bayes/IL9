<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="IL9Cast - Methodology">
    <title>Methodology - IL9Cast</title>
    <link rel="icon" type="image/svg+xml" href="{{ url_for('static', filename='favicon.svg') }}">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;500;600&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='landing-style.css') }}">

    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WVTWQBBG8S"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-WVTWQBBG8S');
    </script>
</head>
<body class="dark-mode">
    <canvas id="grid-canvas"></canvas>

    <div class="site-content">
        <header>
            <a href="/" class="logo">IL9<span>Cast</span></a>
            <nav>
                <a href="/markets">Markets</a>                <a href="/candidates">Candidates</a>
                <a href="/fundraising">Fundraising</a>
                <a href="/methodology" class="active">Methodology</a>
                <a href="/about">About</a>
                <a href="https://github.com/de-bayes/IL9" target="_blank" rel="noopener noreferrer" class="github-link" title="View on GitHub">GitHub</a>
                <a href="https://buy.stripe.com/4gMdR98o72FP77e7jX1sQ00" target="_blank" rel="noopener noreferrer" class="donate-link" title="Support IL9Cast">Donate</a>
            </nav>
        </header>

        <section class="hero">
            <h1>Methodology</h1>
            <p class="subtitle">How IL9Cast generates its forecasts</p>
        </section>

        <section class="methodology-content-page">

            <!-- FOLDOUT 1: Prediction Markets Aggregation -->
            <div class="method-foldout" id="foldout-pm">
                <button class="foldout-trigger" onclick="toggleFoldout('pm')">
                    <div class="foldout-trigger-left">
                        <span class="foldout-icon" id="foldout-icon-pm"></span>
                        <div>
                            <h2>Prediction Markets Aggregation</h2>
                            <p class="foldout-desc">40% Manifold + 60% Kalshi weighted formula</p>
                        </div>
                    </div>
                    <span class="foldout-arrow" id="foldout-arrow-pm">+</span>
                </button>
                <div class="foldout-body" id="foldout-body-pm">
                    <div class="foldout-inner">
                        <p>The <a href="/markets">Markets page</a> aggregates real-time probabilities from two major prediction markets: <strong>Manifold Markets</strong> (community-driven) and <strong>Kalshi</strong> (real-money exchange). This provides a live, crowd-sourced forecast updated automatically as new trades occur.</p>

                        <h3>Overall Weighting: 40% Manifold + 60% Kalshi</h3>

                        <p><strong>Manifold Markets (40% weight):</strong></p>
                        <ul class="method-list">
                            <li>Community prediction market using play money</li>
                            <li>Lower barrier to entry, broader participation</li>
                            <li>Captures general consensus and casual forecasters</li>
                            <li>Uses an Automated Market Maker (AMM) for price discovery</li>
                            <li>Good for long-term sentiment, less susceptible to short-term noise</li>
                        </ul>

                        <p><strong>Kalshi (60% weight):</strong></p>
                        <ul class="method-list">
                            <li>Real-money exchange with cash-settled contracts</li>
                            <li>Higher barrier to entry, attracts serious forecasters with skin in the game</li>
                            <li>Reflects genuine conviction (money is at risk)</li>
                            <li>Traditional order book exchange (bid/ask spread pricing)</li>
                        </ul>

                        <h3>Kalshi Component Breakdown (60% total weight)</h3>

                        <p>Within Kalshi's 60% weight, we use three price signals:</p>

                        <p><strong>1. Last Price (42% overall = 70% of Kalshi's 60%)</strong></p>
                        <ul class="method-list">
                            <li>The most recent completed trade price</li>
                            <li>Reflects real money execution and recent market sentiment</li>
                            <li>Given highest weight because it shows actual conviction backed by capital</li>
                            <li>Most responsive to new information and recent trades</li>
                        </ul>

                        <p><strong>2. Midpoint (12% overall = 20% of Kalshi's 60%)</strong></p>
                        <ul class="method-list">
                            <li>Average of the current best bid and best ask prices: (bid + ask) / 2</li>
                            <li>Represents the fair value between buyers and sellers right now</li>
                            <li>Includes current order book state but not yet executed</li>
                            <li>Smooths out last trade anomalies or outliers</li>
                        </ul>

                        <p><strong>Thin-Market Fallback (Midpoint &amp; Liquidity)</strong></p>
                        <p>When a candidate has <strong>no yes-side bids</strong> (yes_bid = 0), the standard midpoint formula (yes_bid + yes_ask) / 2 produces a meaningless number — it averages zero against the ask, massively inflating the result. In these cases, both the Midpoint and Liquidity-Weighted components fall back to the candidate's <strong>last trade price</strong> instead.</p>
                        <p><strong>Example — Mike Simmons:</strong> Simmons has virtually no buy-side interest on Kalshi. His order book might show yes_bid = 0, yes_ask = 19, last_price = 1. Without the fallback, the midpoint formula would compute (0 + 19) / 2 = 9.5%, and the liquidity-weighted price would land around 9.0% — suggesting nearly 10% support for a candidate trading at 1 cent. With the fallback, both Midpoint and Liquidity correctly report 1%, matching his actual last trade. The spread-based liquidity adjustment is also skipped entirely because there is no real two-sided market to analyze.</p>

                        <p><strong>3. Liquidity-Weighted Price (6% overall = 10% of Kalshi's 60%)</strong></p>
                        <ul class="method-list">
                            <li><strong>Purpose:</strong> Captures buying vs selling pressure by analyzing where the last trade occurred within the bid-ask spread</li>
                            <li><strong>Why only Kalshi?</strong> Kalshi uses a traditional order book exchange where buyers and sellers post bids and asks. Manifold uses an Automated Market Maker (AMM) that algorithmically sets prices, so order book analysis doesn't apply</li>
                            <li><strong>How it works:</strong> Calculate position in spread = (Last Price - Bid) / (Ask - Bid). Position of 0.0 = traded at bid (sellers aggressive), 0.5 = at midpoint (balanced), 1.0 = at ask (buyers aggressive)</li>
                            <li><strong>Spread dampening:</strong> Wider spreads reduce the adjustment because they indicate less confidence. At 0pp spread: factor = 1.0 (full shift potential). At 10pp spread: factor = 0.2 (heavily dampened)</li>
                            <li><strong>Example:</strong> Bid=60, Ask=68, Last=66, Mid=64, Spread=8. Position = (66-60)/8 = 0.75 (near ask). Offset = 0.75 - 0.5 = +0.25. Dampening = 1 - (8/10)×0.8 = 0.36. Shift = 0.25 × 6 × 0.36 = +0.54pp. Result = 64 + 0.54 = 64.5% (buyers showed aggression)</li>
                            <li>Caps shift at ±3 percentage points to avoid overreaction</li>
                        </ul>

                        <h3>The Complete Formula</h3>
                        <div class="formula-box">
                            Aggregate Probability = (0.40 × Manifold) + (0.42 × Kalshi Last Price) + (0.12 × Kalshi Midpoint) + (0.06 × Kalshi Liquidity-Weighted)
                        </div>

                        <h3>Soft Normalization (30% Strength)</h3>
                        <p>Final probabilities are lightly normalized to prevent excessive drift while preserving raw market values:</p>
                        <ul class="method-list">
                            <li>Candidates with no Kalshi market (marked with *) use 100% of their Manifold probability</li>
                            <li>Only 30% of the normalization adjustment is applied to each candidate</li>
                            <li>70% of the raw aggregated value is preserved</li>
                            <li>This keeps top candidates higher while preventing probabilities from summing to unrealistic totals</li>
                        </ul>

                        <h3>Chart Smoothing</h3>
                        <p>To produce clean, readable trend lines, the chart pipeline applies multiple smoothing layers:</p>
                        <ul class="method-list">
                            <li><strong>Spike dampening:</strong> Per-candidate probability changes are capped at ±3 percentage points per 3-minute collection interval, preventing sudden jumps from thin-market trades or API glitches</li>
                            <li><strong>Exponential Moving Average (EMA):</strong> Chart data is smoothed server-side with an EMA (alpha = 0.15) — each displayed point is 15% new value + 85% previous smoothed value</li>
                            <li><strong>RDP simplification:</strong> The Ramer-Douglas-Peucker algorithm reduces thousands of raw data points to ~200-400 visually significant points, removing redundant noise</li>
                            <li><strong>Monotone cubic interpolation:</strong> The frontend renders curves using monotone splines that prevent overshoot between data points</li>
                        </ul>

                        <h3>Update Frequency</h3>
                        <ul class="method-list">
                            <li><strong>Default:</strong> Every 3 minutes</li>
                            <li><strong>Final 3 days before election:</strong> Every 1 minute</li>
                            <li><strong>Election day:</strong> Every 1 minute</li>
                        </ul>

                        <p>Historical snapshots are saved with every update and aggregated hourly for clean trend visualization.</p>

                        <h3 id="heatmap-methodology">Results Heatmap (1st &amp; 2nd Place Probabilities)</h3>
                        <p>The <a href="/markets">Markets page</a> includes a results heatmap showing the derived probability of every possible 1st-place and 2nd-place finish combination. Since prediction markets only provide marginal win probabilities (P(candidate wins)), we derive the joint probabilities using conditional probability:</p>

                        <div class="formula-box">
                            <strong>Joint probability formula:</strong><br>
                            P(A finishes 1st, B finishes 2nd) = P(A wins) &times; P(B wins) / (1 &minus; P(A wins))
                        </div>

                        <p><strong>Intuition:</strong> If candidate A wins (with probability P(A)), the remaining candidates compete for 2nd place. We assume their relative win probabilities determine who finishes 2nd. So candidate B's chance of finishing 2nd, given A won, equals B's probability renormalized among all non-A candidates: P(B) / (1 &minus; P(A)). Multiplying by P(A) gives the joint probability of A finishing 1st <em>and</em> B finishing 2nd.</p>

                        <p><strong>Key assumption:</strong> This treats candidates as independent — it assumes that A winning doesn't change the relative ordering of the remaining candidates. In practice, ideologically similar candidates may cannibalize each other's support, which would make some 2nd-place finishes more or less likely than this model predicts. The heatmap is a first-order approximation, not a full correlated model.</p>

                        <p><strong>Reading the heatmap:</strong> Rows represent the 1st-place finisher, columns represent the 2nd-place finisher. The diagonal is empty (a candidate can't finish both 1st and 2nd). Brighter orange cells indicate higher probability pairs. The most likely 1st/2nd combination is highlighted at the top.</p>
                    </div>
                </div>
            </div>

            <!-- FOLDOUT 2: Forecast Model -->
            <div class="method-foldout" id="foldout-model">
                <button class="foldout-trigger" onclick="toggleFoldout('model')">
                    <div class="foldout-trigger-left">
                        <span class="foldout-icon" id="foldout-icon-model"></span>
                        <div>
                            <h2>Forecast Model</h2>
                            <p class="foldout-desc">Multi-factor probabilistic model</p>
                        </div>
                    </div>
                    <span class="foldout-arrow" id="foldout-arrow-model">+</span>
                </button>
                <div class="foldout-body" id="foldout-body-model">
                    <div class="foldout-inner">
                        <div class="coming-soon-block">
                            <span class="coming-soon-icon">&#9881;</span>
                            <h3>Coming Soon</h3>
                            <p>The forecast model methodology will be published here once the model is live on the <a href="/odds">Model page</a>. It will incorporate prediction market data, fundraising metrics, endorsement signals, and historical primary patterns to generate win probabilities for each candidate.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- FOLDOUT 3: Fundraising Analysis -->
            <div class="method-foldout" id="foldout-fundraising">
                <button class="foldout-trigger" onclick="toggleFoldout('fundraising')">
                    <div class="foldout-trigger-left">
                        <span class="foldout-icon" id="foldout-icon-fundraising"></span>
                        <div>
                            <h2>Fundraising Analysis</h2>
                            <p class="foldout-desc">FEC filing data and financial metrics</p>
                        </div>
                    </div>
                    <span class="foldout-arrow" id="foldout-arrow-fundraising">+</span>
                </button>
                <div class="foldout-body" id="foldout-body-fundraising">
                    <div class="foldout-inner">

                        <p>The <a href="/fundraising">Fundraising page</a> aggregates campaign finance data directly from the Federal Election Commission's public API. This gives us real-time insights into total raised, cash on hand, spending patterns, and grassroots support metrics for all candidates in the race.</p>

                        <h3>FEC API Data Sources</h3>
                        <p>We pull data from two primary FEC API endpoints:</p>
                        <div class="formula-box">
                            <strong>Candidate Totals:</strong> <code>GET /v1/candidate/{candidate_id}/totals/</code><br>
                            Returns aggregate financial summary including receipts, disbursements, cash on hand, and individual contribution breakdowns.
                        </div>
                        <div class="formula-box" style="margin-top: 0.75rem;">
                            <strong>Disbursements:</strong> <code>GET /v1/schedules/schedule_b/</code><br>
                            Returns itemized expenditure records (Schedule B) used for burn rate calculations.
                        </div>
                        <p>Each candidate is identified by their FEC candidate ID (format: <code>H6IL09XXX</code>). We map candidate names to their IDs and then query their principal campaign committee for financial data. For example:</p>
                        <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                            <li><strong>Daniel Biss</strong> → H6IL09228 → Committee C00855619</li>
                            <li><strong>Kat Abughazaleh</strong> → H6IL09178 → Committee C00851154</li>
                            <li><strong>Mike Simmons</strong> → H6IL09293 → Committee C00857847</li>
                        </ul>

                        <h3>Small Dollar Donations</h3>
                        <p>The "Small $%" metric measures grassroots support by calculating what percentage of a candidate's individual contributions come from donations under $200. This is the FEC's standard definition of small-dollar/grassroots fundraising.</p>
                        <p><strong>Calculation formula:</strong></p>
                        <div class="formula-box">
                            Small Dollar % = (individual_unitemized_contributions ÷ individual_contributions) × 100
                        </div>
                        <p>The FEC breaks down individual contributions into two categories:</p>
                        <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                            <li><strong>Itemized contributions</strong> — Individual donations of $200 or more (reported with donor names)</li>
                            <li><strong>Unitemized contributions</strong> — Individual donations under $200 (aggregated without names)</li>
                        </ul>
                        <p><strong>Why we use individual_contributions as the denominator:</strong> Total receipts include PAC money, party transfers, and other non-individual sources. To accurately measure grassroots support, we only consider money from individual human donors.</p>
                        <p><strong>Real example from Kat Abughazaleh's FEC data:</strong></p>
                        <div class="formula-box">
                            Individual contributions (total): $2,702,469.35<br>
                            Unitemized (under $200): $1,898,015.77<br>
                            Itemized ($200+): $804,453.58<br><br>
                            Small Dollar % = ($1,898,015.77 ÷ $2,702,469.35) × 100 = <strong>70.2%</strong>
                        </div>
                        <p>This means 70.2% of Kat's individual donations came from contributors giving less than $200 — a strong indicator of broad grassroots support.</p>

                        <h3>Burn Rate Projections</h3>
                        <p>Burn rate measures how quickly a campaign is spending money, projected forward to estimate monthly cash consumption. We calculate three different burn rate metrics using real disbursement data from FEC Schedule B filings:</p>
                        <div class="formula-box">
                            <strong>2-Week Burn:</strong> Last 2 weeks expenditures × 2 = monthly rate<br>
                            <strong>1-Month Burn:</strong> Last 1 month expenditures = monthly rate<br>
                            <strong>1.5-Month Burn:</strong> Last 1.5 months expenditures × 0.66 = monthly rate
                        </div>
                        <p>For each candidate, we:</p>
                        <ol style="margin-left: 1.5rem; margin-top: 0.5rem;">
                            <li>Get their most recent FEC filing's <code>coverage_end_date</code></li>
                            <li>Query Schedule B for all disbursements in the lookback period (14, 30, or 45 days)</li>
                            <li>Sum total disbursement amounts for that period</li>
                            <li>Multiply by the appropriate factor to normalize to a 30-day monthly rate</li>
                        </ol>
                        <p>This gives us three perspectives on spending velocity: recent (2-week), medium-term (1-month), and longer-term (1.5-month). Campaigns often ramp up spending closer to election day, so the 2-week burn tends to be highest.</p>
                        <p><strong>Implementation:</strong> The system first finds the most recent disbursement within the last 60 days of the reporting period. If found, it uses that date as the anchor point and calculates backwards. If no recent disbursements exist, burn rates show as $0/mo.</p>
                        <p><strong>Note:</strong> Many campaigns show $0/mo burn rates because they had no expenditures in the final weeks of the Dec 31, 2025 reporting period. This is normal for campaigns between quarterly filing deadlines.</p>

                        <h3>Data Source & Updates</h3>
                        <p>The fundraising data is currently <strong>hardcoded</strong> into the application using FEC filings as of December 31, 2025 (retrieved February 1, 2026). Since campaigns won't file new quarterly reports until April 2026, the data is static and doesn't require live API calls.</p>
                        <p>This approach provides instant page loads (no 2-3 second API delays) while ensuring the displayed data remains accurate. When new FEC reports are filed in April, the hardcoded data will be updated to reflect the latest filings.</p>

                        <h3>Chart Visualization</h3>
                        <p>The fundraising chart uses a dual Y-axis approach to compare two fundamentally different metrics:</p>
                        <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                            <li><strong>Orange bars (left Y-axis):</strong> Total dollars raised, scaled in currency</li>
                            <li><strong>Blue bars (right Y-axis):</strong> Percentage of raised funds spent, scaled 0-100%</li>
                        </ul>
                        <p>The blue bars are nested inside the orange bars (same X position, narrower width) to save horizontal space while keeping both metrics independently readable on their own scales. This nested-bar technique is implemented using Chart.js with <code>stack: 'combined'</code> and <code>stacked: false</code> to center both bars at the same position without summing their values.</p>

                    </div>
                </div>
            </div>

            <!-- FOLDOUT 4: Infrastructure & Technical Details -->
            <div class="method-foldout" id="foldout-infra">
                <button class="foldout-trigger" onclick="toggleFoldout('infra')">
                    <div class="foldout-trigger-left">
                        <span class="foldout-icon" id="foldout-icon-infra"></span>
                        <div>
                            <h2>Infrastructure &amp; Technical Stack</h2>
                            <p class="foldout-desc">Railway, JSONL storage, and the data pipeline under the hood</p>
                        </div>
                    </div>
                    <span class="foldout-arrow" id="foldout-arrow-infra">+</span>
                </button>
                <div class="foldout-body" id="foldout-body-infra">
                    <div class="foldout-inner">

                        <p>IL9Cast is a pretty lean operation — a single Python app running on Railway that does everything from fetching market data to serving the website. Here's how it all fits together.</p>

                        <h3>The Cloud Setup</h3>
                        <p>We run on <strong>Railway</strong>, which is a platform-as-a-service that deploys straight from GitHub. Every time we push code to the <code>main</code> branch, Railway automatically builds and deploys a new version using Nixpacks (their build system). The whole deploy cycle takes about 30 seconds.</p>
                        <p>The app runs behind <strong>Gunicorn</strong>, a production-grade Python WSGI server. We use the <code>--preload</code> flag, which is important — it loads the app once in memory before forking workers, so our background data collector only starts a single thread instead of duplicating itself across workers. Without that flag, you'd get multiple scrapers all writing to the same file at the same time, which is a recipe for corrupted data.</p>
                        <p>Here's the key configuration from <code>railway.toml</code>:</p>
                        <div class="formula-box" style="font-size: 0.95rem;">
                            startCommand = "gunicorn app:app --preload"<br>
                            healthcheckPath = "/"<br>
                            restartPolicyType = "ON_FAILURE"<br>
                            restartPolicyMaxRetries = 10
                        </div>
                        <p>That restart policy is our safety net. If the app crashes — maybe a dependency breaks, maybe Railway has a hiccup — it'll automatically restart up to 10 times before giving up. In practice, it almost never needs more than one.</p>

                        <h3>Persistent Storage (the tricky part)</h3>
                        <p>Railway containers are ephemeral by default — when the app redeploys, everything on the filesystem gets wiped. That's fine for code, but our historical data needs to survive between deploys. So we use a <strong>Railway persistent volume</strong> mounted at <code>/app/data</code>.</p>
                        <p>When the app boots up, it runs a path resolution function that checks, in order: <code>/data</code>, <code>/app/data</code>, then falls back to a local <code>data/</code> directory. This means the same code works on Railway (where the volume lives at <code>/app/data</code>) and on a developer's laptop (where it just uses the local folder). No environment variables, no conditional imports — just a directory check.</p>

                        <h3>Why JSONL (and not a database)</h3>
                        <p>You might wonder why we're storing data in a flat file instead of PostgreSQL or SQLite. Honestly? For our use case, JSONL is better.</p>
                        <p><strong>JSONL</strong> (JSON Lines) means one JSON object per line. Every 3 minutes, the scraper appends a single line to the file — that's it. No connection pools, no schema migrations, no ORM overhead. The file is human-readable (you can literally <code>tail</code> it to see the latest data), and if a line gets corrupted, every other line is still perfectly valid. Try saying that about a SQLite database after a partial write.</p>
                        <p>The append operation is actually a bit more careful than a simple file write:</p>
                        <ul class="method-list">
                            <li><strong>Write to a temp file first</strong> — the new snapshot goes to <code>historical_snapshots.jsonl.tmp</code></li>
                            <li><strong>Copy existing content + new line</strong> — both old data and the new snapshot get written to the temp file</li>
                            <li><strong>Atomic replace</strong> — <code>os.replace()</code> swaps the temp file into place in a single filesystem operation. If the app crashes mid-write, either the old file or the new file exists — never a half-written mess</li>
                        </ul>
                        <p>At 480 snapshots per day (~3 KB each), the file grows at roughly 1.4 MB/day. After a full election cycle, we're looking at maybe 70 MB total. That's nothing — your phone has thousands of times more storage. A database would be overkill here.</p>

                        <h3>The Data Collection Loop</h3>
                        <p>Every 3 minutes, a background thread wakes up and runs our <code>collect_market_data()</code> function. Here's what happens in those few hundred milliseconds:</p>
                        <ul class="method-list">
                            <li><strong>1. Fetch Manifold</strong> — HTTP GET to their public API. Returns JSON with each candidate's probability (0.0–1.0 scale, which we multiply by 100). Timeout: 10 seconds.</li>
                            <li><strong>2. Fetch Kalshi</strong> — HTTP GET to their trade API. Returns an array of markets, each with <code>last_price</code>, <code>yes_bid</code>, and <code>yes_ask</code>. Same 10-second timeout.</li>
                            <li><strong>3. Normalize names</strong> — Manifold calls her "Kat Abughazaleh" and Kalshi calls her "Katheryn Abughazaleh." We strip prefixes, suffixes, and known variations to get a canonical key for matching.</li>
                            <li><strong>4. Aggregate</strong> — Apply the 40/42/12/6 weighted formula (see the Markets Aggregation section above).</li>
                            <li><strong>5. Soft normalize</strong> — Nudge probabilities 30% toward summing to 100%, so the chart doesn't show the race at 130% or 80% total.</li>
                            <li><strong>6. Spike dampen</strong> — Compare to the previous snapshot. If any candidate moved more than ±3 percentage points, clamp the change. This prevents chart artifacts from thin-market Kalshi trades.</li>
                            <li><strong>7. Save</strong> — Atomically append to the JSONL file.</li>
                        </ul>
                        <p>If <em>both</em> APIs fail (say Manifold is down and Kalshi returns an error), we skip the snapshot entirely. Bad data is worse than missing data — the chart just won't have a point for that 3-minute window, and the gap detection handles it gracefully.</p>

                        <h3>The Scheduler Problem</h3>
                        <p>Running a background task alongside a web server sounds simple, but there's a subtle gotcha. When you run Flask locally, you get one process — easy. But Gunicorn can spawn multiple worker processes, and each one would try to run its own scheduler. That means two workers = two scrapers = double the data (and double the API calls).</p>
                        <p>We solve this two ways depending on the environment:</p>
                        <ul class="method-list">
                            <li><strong>Local development:</strong> Uses APScheduler's <code>BackgroundScheduler</code>, which runs the job in a background thread within the single Flask process.</li>
                            <li><strong>Production (Gunicorn):</strong> Detects Gunicorn via <code>sys.argv[0]</code> and instead spins up a plain <code>threading.Thread</code> in daemon mode. The <code>--preload</code> flag ensures this thread is created once in the master process before workers fork, so only one thread ever exists.</li>
                        </ul>

                        <h3>Chart Data Pipeline</h3>
                        <p>When you load the Markets page, your browser hits <code>/api/snapshots/chart?period=1d</code> (or <code>7d</code> or <code>all</code>). Here's what the server does before sending data back:</p>
                        <ul class="method-list">
                            <li><strong>Cache check</strong> — We keep a 60-second in-memory cache. If the same period was requested within the last minute, we serve the cached version instantly.</li>
                            <li><strong>Load &amp; filter</strong> — Read all snapshots from the JSONL file, parse timestamps, sort chronologically, and filter to the requested time window.</li>
                            <li><strong>Gap detection</strong> — Scan consecutive timestamps for gaps &gt; 2 hours. These become the dashed-line segments on the chart — they represent real outages (Railway restarts, AWS issues), not normal 3-minute intervals.</li>
                            <li><strong>EMA smoothing</strong> — Run an exponential moving average (alpha = 0.15) across each candidate's probability series. This is the biggest smoothing step — each data point becomes 15% raw value + 85% previous smoothed value, which kills jitter while preserving genuine trends.</li>
                            <li><strong>RDP simplification</strong> — The Ramer-Douglas-Peucker algorithm finds which points you can remove without changing the visual shape of the line (within an epsilon tolerance of 0.5 percentage points). A week of data at 3-minute intervals = ~3,360 points per candidate. After RDP, that drops to maybe 200–400 points. Your browser thanks us.</li>
                        </ul>
                        <p>The RDP algorithm is actually kind of elegant. Imagine drawing a straight line from the first data point to the last. Now find whichever intermediate point is farthest from that line. If it's farther than epsilon, that point matters — keep it, and recursively check both halves. If it's closer than epsilon, the whole segment is "flat enough" to represent with just the endpoints. It's O(n log n) on average and perfectly preserves peaks, valleys, and inflection points while throwing away the boring flat stretches.</p>

                        <h3>The Frontend Rendering</h3>
                        <p>The chart itself is rendered with <strong>Chart.js</strong> using a time-scaled x-axis. The data comes in as <code>{x: timestamp, y: probability}</code> pairs, and Chart.js handles the rest. A few important settings:</p>
                        <ul class="method-list">
                            <li><strong>Monotone cubic interpolation</strong> — This is the <code>cubicInterpolationMode: 'monotone'</code> setting. Regular cubic splines can "overshoot" — if a candidate goes from 60% to 62%, a regular spline might draw a curve that briefly dips to 59% between the points. Monotone splines guarantee the curve never exceeds the actual data values. No fake dips, no fake peaks.</li>
                            <li><strong>Tension 0.5</strong> — Controls how curvy the lines are. At 0 you get straight segments (ugly). At 1 you get maximally curvy (too smooth, hides real movement). 0.5 is the sweet spot.</li>
                            <li><strong>Central Time display</strong> — All timestamps are stored in UTC but displayed in Central Time (America/Chicago) using <code>Intl.DateTimeFormat</code>. This handles daylight saving transitions automatically — no hardcoded offsets.</li>
                            <li><strong>Segment styling for gaps</strong> — Chart.js lets you style individual line segments. For each segment, we check if the two endpoints span a known gap period. If they do, the segment gets dashed and faded. This is done per-frame via a callback, so it works even when you zoom or pan.</li>
                        </ul>

                        <h3>What Could Go Wrong (and what we do about it)</h3>
                        <p>A few things have bitten us before, so we built defenses:</p>
                        <ul class="method-list">
                            <li><strong>API timeouts:</strong> Both Manifold and Kalshi calls have 10-second timeouts. If they're slow, we fail fast instead of blocking the scheduler thread.</li>
                            <li><strong>Partial API failure:</strong> If only one API goes down, we still collect what we can, but spike dampening prevents the sudden weight shift from creating chart artifacts.</li>
                            <li><strong>Railway restarts:</strong> The persistent volume survives container restarts. When the app boots, it checks for existing data and picks up where it left off.</li>
                            <li><strong>Corrupt JSONL lines:</strong> The reader skips unparseable lines and logs a warning. One bad line doesn't take down the whole dataset — that's the beauty of line-delimited formats.</li>
                            <li><strong>Duplicate schedulers:</strong> The Gunicorn <code>--preload</code> + <code>sys.argv</code> detection ensures exactly one scraper thread exists in production.</li>
                        </ul>

                        <h3>Dependencies</h3>
                        <p>The whole app runs on five Python packages:</p>
                        <div class="formula-box" style="font-size: 0.95rem;">
                            Flask 2.3.2 &nbsp;&mdash;&nbsp; web framework<br>
                            Werkzeug 2.3.6 &nbsp;&mdash;&nbsp; WSGI utilities (Flask dependency)<br>
                            Requests 2.31.0 &nbsp;&mdash;&nbsp; HTTP client for API calls<br>
                            Gunicorn 21.2.0 &nbsp;&mdash;&nbsp; production WSGI server<br>
                            APScheduler 3.10.4 &nbsp;&mdash;&nbsp; background job scheduling (dev mode)
                        </div>
                        <p>No NumPy, no Pandas, no heavyweight data libraries. The EMA, RDP, and aggregation math are all hand-written in ~100 lines of plain Python. For a project that processes a few hundred data points, there's no reason to import a 30 MB library.</p>

                    </div>
                </div>
            </div>

            <article class="method-section contact-section">
                <h2>Questions?</h2>
                <p>IL9Cast's prediction market aggregation is maintained by <strong>Ryan McComb</strong>, a student at ETHS, as an educational project to help voters understand real-time sentiment in the Illinois 9th Democratic Primary race.</p>
                <p>For questions about the market aggregation methodology or to report data issues, please reach out directly.</p>
            </article>
        </section>

        <footer class="site-footer">
            <div class="footer-content">
                <div class="footer-section">
                    <h4>About</h4>
                    <ul>
                        <li><a href="/about">About IL9Cast</a></li>
                        <li><a href="/methodology">Methodology</a></li>
                        <li><a href="https://github.com/de-bayes/IL9" target="_blank" rel="noopener noreferrer">GitHub</a></li>
                    </ul>
                </div>
                <div class="footer-section">
                    <h4>Markets</h4>
                    <ul>
                        <li><a href="/markets">Live Markets</a></li>
                        <li><a href="/markets">Download Data</a></li>
                        <li>Updated every 3 minutes</li>
                    </ul>
                </div>
                <div class="footer-section">
                    <h4>Disclaimer</h4>
                    <p>Prediction markets involve risk. Past performance does not guarantee future results. This platform aggregates public market data for informational purposes.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2026 IL9Cast. Built with open data. • Railway & AWS Storage: Live • <a href="https://buy.stripe.com/4gMdR98o72FP77e7jX1sQ00" target="_blank" rel="noopener noreferrer" class="footer-support-link">Support This Project</a></p>
            </div>
        </footer>
    </div>

    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            min-height: 100vh;
        }

        .methodology-content-page {
            max-width: 900px;
            margin: 0 auto 4rem;
            padding: 0 2rem;
        }

        /* ===== FOLDOUT STYLES ===== */
        .method-foldout {
            background: rgba(18, 18, 22, 1);
            
            -webkit-
            border: 1px solid rgba(91, 155, 213, 0.25);
            border-radius: 8px;
            margin-bottom: 1.5rem;
            overflow: hidden;
        }

        .foldout-trigger {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1.8rem 2.2rem;
            background: none;
            border: none;
            cursor: pointer;
            text-align: left;
            color: inherit;
            transition: background 0.3s ease;
        }

        .foldout-trigger:hover {
            background: rgba(91, 155, 213, 0.05);
        }

        .foldout-trigger-left {
            display: flex;
            align-items: center;
            gap: 1.2rem;
        }

        .foldout-icon {
            width: 44px;
            height: 44px;
            border-radius: 10px;
            background: rgba(25, 25, 30, 1);
            border: 1px solid rgba(91, 155, 213, 0.25);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .foldout-trigger h2 {
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-size: 1.6rem;
            font-weight: 600;
            color: #5B9BD5;
            margin: 0;
            line-height: 1.3;
        }

        .foldout-desc {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.45);
            margin: 0.2rem 0 0 0;
            line-height: 1.4;
        }

        .foldout-arrow {
            font-family: 'Inter', sans-serif;
            font-size: 1.6rem;
            font-weight: 300;
            color: rgba(91, 155, 213, 0.5);
            transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            flex-shrink: 0;
            width: 30px;
            text-align: center;
            line-height: 1;
        }

        .foldout-arrow.open {
            transform: rotate(45deg);
        }

        .foldout-body {
            display: grid;
            grid-template-rows: 0fr;
            transition: grid-template-rows 0.5s cubic-bezier(0.34, 1.12, 0.64, 1),
                        opacity 0.4s ease;
            opacity: 0;
        }

        .foldout-body.open {
            grid-template-rows: 1fr;
            opacity: 1;
        }

        .foldout-inner {
            overflow: hidden;
            padding: 0 2.2rem;
        }

        .foldout-body.open .foldout-inner {
            padding-bottom: 2.2rem;
        }

        .foldout-body .foldout-inner {
            border-top: 1px solid rgba(160, 160, 160, 0.12);
            padding-top: 0;
            transition: padding-top 0.4s ease;
        }

        .foldout-body.open .foldout-inner {
            padding-top: 1.8rem;
        }

        /* Active/open foldout border glow */
        .method-foldout.active {
            border-color: rgba(91, 155, 213, 0.4);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);
        }

        /* ===== COMING SOON BLOCK ===== */
        .coming-soon-block {
            text-align: center;
            padding: 2rem 1rem;
        }

        .coming-soon-icon {
            font-size: 2.5rem;
            display: block;
            margin-bottom: 0.8rem;
            opacity: 0.4;
        }

        .coming-soon-block h3 {
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-size: 1.5rem;
            font-weight: 600;
            color: rgba(91, 155, 213, 0.5);
            margin-bottom: 0.8rem;
        }

        .coming-soon-block p {
            color: rgba(255, 255, 255, 0.45);
            max-width: 550px;
            margin: 0 auto;
            line-height: 1.7;
        }

        .coming-soon-block a {
            color: #5B9BD5;
            text-decoration: underline;
        }

        /* ===== INNER CONTENT STYLES ===== */
        .foldout-inner h3 {
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-size: 1.4rem;
            font-weight: 600;
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: #5B9BD5;
        }

        .foldout-inner p {
            margin-bottom: 1rem;
            line-height: 1.8;
            color: #c0c0c0;
        }

        .foldout-inner a {
            color: #5B9BD5;
            text-decoration: underline;
        }

        .foldout-inner a:hover {
            opacity: 0.8;
        }

        .method-list {
            list-style: none;
            padding-left: 0;
            margin: 1rem 0;
        }

        .method-list li {
            margin-bottom: 0.8rem;
            padding-left: 1.5rem;
            position: relative;
            line-height: 1.6;
            color: #c0c0c0;
        }

        .method-list li:before {
            content: "\2192";
            position: absolute;
            left: 0;
            color: #5B9BD5;
        }

        .formula-box {
            font-family: 'Inter', sans-serif; font-weight: 600;
            background: rgba(25, 25, 30, 1);
            border-left: 3px solid #5B9BD5;
            padding: 1.5rem;
            border-radius: 4px;
            margin: 1.5rem 0;
            font-size: 1.1rem;
            color: #e0e0e0;
        }

        /* ===== CONTACT SECTION ===== */
        .method-section {
            background: rgba(18, 18, 22, 1);
            
            -webkit-
            border: 1px solid rgba(91, 155, 213, 0.25);
            border-radius: 8px;
            padding: 2.5rem;
            margin-bottom: 2rem;
        }

        .method-section h2 {
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-size: 2rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: #5B9BD5;
        }

        .method-section p {
            margin-bottom: 1rem;
            line-height: 1.8;
            color: #c0c0c0;
        }

        .contact-section {
            border-color: rgba(91, 155, 213, 0.4);
        }

        /* ===== RESPONSIVE ===== */
        @media (max-width: 600px) {
            .foldout-trigger {
                padding: 1.2rem 1.4rem;
            }
            .foldout-trigger h2 {
                font-size: 1.25rem;
            }
            .foldout-inner {
                padding: 0 1.4rem;
            }
            .foldout-body.open .foldout-inner {
                padding-bottom: 1.4rem;
            }
            .foldout-icon {
                width: 36px;
                height: 36px;
            }
        }
    </style>

    <script>
        function toggleFoldout(id) {
            const body = document.getElementById('foldout-body-' + id);
            const arrow = document.getElementById('foldout-arrow-' + id);
            const foldout = document.getElementById('foldout-' + id);
            const isOpen = body.classList.contains('open');

            body.classList.toggle('open');
            arrow.classList.toggle('open');
            foldout.classList.toggle('active');
        }

        // GRID BACKGROUND - Static, no mouse interaction
        const canvas = document.getElementById('grid-canvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 40;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            drawGrid();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const isDarkMode = document.body.classList.contains('dark-mode');
            ctx.strokeStyle = isDarkMode ? 'rgba(255, 255, 255, 0.08)' : 'rgba(0, 0, 0, 0.055)';
            ctx.lineWidth = 1;

            // Draw horizontal lines
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw vertical lines
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
        }

        drawGrid();
    </script>
</body>
</html>
